#!/usr/bin/env node
// Generated by CoffeeScript 2.5.1
// Deps
var Table, analyzeUrl, chalk, chromeLauncher, configs, createProgressBar, defaultProgressTheme, execute, formatRow, formatTime, formatValue, lighthouse, program, ucFirst;

({program} = require('@caporal/core'));

lighthouse = require('lighthouse');

chromeLauncher = require('chrome-launcher');

createProgressBar = require('progress-estimator');

defaultProgressTheme = require('progress-estimator/src/theme');

Table = require('cli-table');

chalk = require('chalk');

// Load Lighthouse configs
configs = {
  desktop: require('lighthouse/lighthouse-core/config/lr-desktop-config.js'),
  mobile: require('lighthouse/lighthouse-core/config/lr-mobile-config.js')
};

// On cntrl-c, trigger normal exit behavior
process.on('SIGINT', function() {
  return process.exit(0);
});

// Setup CLI
program.description('Averages multiple successive Lighthouse tests').argument('<url>', 'The URL to test').option('-t, --times <count>', 'The number of tests to run', {
  default: 10
// Map args and begin running
}).option('-d, --desktop', 'Test only desktop').option('-m, --mobile ', 'Test only mobile').option('-b, --block <urls>', 'Comma seperated URLs to block, wildcards allowed').action(function({
    args: {url},
    options: {times, desktop, mobile, block}
  }) {
  var blockedUrls, devices;
  devices = (function() {
    switch (false) {
      case !mobile:
        return ['mobile'];
      case !desktop:
        return ['desktop'];
      default:
        return ['mobile', 'desktop'];
    }
  })();
  blockedUrls = block ? block.split(',') : [];
  return execute({url, times, devices, blockedUrls});
});

program.run();

// Boot up the runner
execute = async function({url, times, devices, blockedUrls}) {
  var bootChrome, chrome, device, i, j, k, len, len1, progress, results, theme;
  // Create shared progress bar
  theme = defaultProgressTheme;
  theme.asciiInProgress = chalk.hex('#00de6d');
  progress = createProgressBar({theme});
  console.log(""); // Adds a newline
  
  // Create chrome instance that runs test
  bootChrome = chromeLauncher.launch({
    chromeFlags: ['--headless']
  });
  chrome = (await progress(bootChrome, 'Booting Chrome', {
    estimate: 1000
  }));
  process.on('exit', function() {
    return chrome.kill(); // Cleanup
  });
  
  // Loop through each device and run tests
  results = [];
  for (j = 0, len = devices.length; j < len; j++) {
    device = devices[j];
    results.push((await analyzeUrl({url, times, device, blockedUrls, chrome, progress})));
  }
// Output results
  for (i = k = 0, len1 = devices.length; k < len1; i = ++k) {
    device = devices[i];
    console.log("\n\n" + chalk.green.bold(`${ucFirst(device)} Results`));
    console.log(results[i].toString() + "\n");
  }
  // Close Chrome
  return chrome.kill();
};

// Analyze a URL a certain number of times for the provided device
analyzeUrl = async function({url, times, device, blockedUrls, chrome, progress}) {
  var avgs, columns, flags, i, index, j, k, l, len, len1, ref, report, result, results, row, table, time, val;
  // Make the lighthouse config
  flags = {
    onlyCategories: ['performance'],
    blockedUrlPatterns: blockedUrls,
    port: chrome.port
  };
  // Run tests one at a time and collect results
  results = [];
  for (time = j = 1, ref = times; (1 <= ref ? j <= ref : j >= ref); time = 1 <= ref ? ++j : --j) {
    ({report} = (await progress(lighthouse(url, flags, configs[device]), `Testing ${ucFirst(device)} ${time}/${times}`, {
      estimate: 10000
    })));
    results.push(JSON.parse(report));
  }
  // Create output of all results
  columns = ['Score', 'FCP', 'SI', 'LCP', 'TTI', 'TBT', 'CLS'];
  table = new Table({
    head: ['', ...columns],
    style: {
      head: ['green']
    }
  });
  avgs = Array(columns.length).fill(0);
  for (index = k = 0, len = results.length; k < len; index = ++k) {
    result = results[index];
    // Build row content
    row = [result.categories.performance.score, result.audits['first-contentful-paint'].numericValue, result.audits['speed-index'].numericValue, result.audits['largest-contentful-paint'].numericValue, result.audits['interactive'].numericValue, result.audits['total-blocking-time'].numericValue, result.audits['cumulative-layout-shift'].numericValue];
    for (i = l = 0, len1 = avgs.length; l < len1; i = ++l) {
      val = avgs[i];
      // Add to averages list
      avgs[i] += row[i] / times;
    }
    // Format for humans and add to table
    table.push({
      [`#${index + 1}`]: formatRow(row)
    });
  }
  // Add averages and return
  table.push({
    [chalk.bold('AVG')]: formatRow(avgs).map(function(val) {
      return chalk.bold(val);
    })
  });
  return table;
};

// Helper function to format a row of table output for human readibility
formatRow = function(row) {
  var cls, fcp, lcp, score, si, tbt, tti;
  [score, fcp, si, lcp, tti, tbt, cls] = row;
  return [formatValue(score * 100), formatTime(fcp), formatTime(si), formatTime(lcp), formatTime(tti), formatTime(tbt), formatValue(cls, 3)];
};

// Convert ms to s
formatTime = function(ms) {
  if (ms >= 1000) {
    return formatValue(ms / 1000) + 's';
  } else {
    return Math.round(ms) + 'ms';
  }
};

// Round to a decimal value
formatValue = function(num, depth = 1) {
  return num.toLocaleString('en-US', {
    minimumFractionDigits: 0,
    maximumFractionDigits: depth
  });
};

// Capitalize first letter
ucFirst = function(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
};
